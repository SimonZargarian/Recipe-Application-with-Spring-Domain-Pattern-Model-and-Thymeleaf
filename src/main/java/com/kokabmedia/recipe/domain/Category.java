package com.kokabmedia.recipe.domain;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;

import javax.persistence.*;
import javax.validation.constraints.NotNull;

import java.util.Set;

/*
 * This class will handle the modelling of the database tables and also function as model for 
 * communication between the database and this application.
 * 
 * It will also act as a model class for values bounded to the HTML view file properties.
 * 
 * Getter and Setter methods and constructors of this class is provided with the Lombok framework. 
 * Getter setter methods and  constructors will be automatically generated by Lombok framework 
 * under the hood.
 */
@Getter
@Setter
/*
 * Generates hashCode and equals implementations from the fields of your object. When a class 
 * definition is annotated with @EqualsAndHashCode to let Lombok generate implementations of the 
 * equals(Object other) and hashCode() methods. 
 */
@EqualsAndHashCode(exclude = {"recipes"})
/* 
 * The @Entity annotation from javax.persistence enables the JPA framework to manage 
 * the Category class as a JPA entity. The Category class is an entity and will be  
 * mapped to a database table with the name Category by Hibernate. 
 * 
 * The @Entity annotation will automatically with Hibernate, JPA and Spring auto 
 * configuration create a Category table in the database.
 */
@Entity
public class Category {


	/*
	 * The @Id annotation makes this field a primary key in the database table.
	 * 
	 * The @GeneratedValue annotation makes the Hibernate generate the primary key value.
	 * 
	 * The GenerationType.IDENTITY parameter indicates that the id will be generated by the
	 * database.
	 * 
	 * Primary key will uniquely identify each row in a database table.
	 */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String description;

    /*
	 * The @ManyToMany annotation indicates that Category can have many Recipes and a Recipe
	 * can be associated with many Categories. Category can have a list of multiple Recipes.
	 *
	 * The @ManyToMany annotation will not create a new Recipe_Category joint table in the  
	 * database with recipe_id and catogory_id columns with foreign key values, because 
	 * Recipe will be the owning side of the relationship with the mappedby parameter and the 
	 * @JoinTable annotation.
	 * 
	 * The fetch strategy for the ManyToMany side of the relations is Lazy Fetch.
	 */
    @ManyToMany(mappedBy = "categories")
    private Set<Recipe> recipes;

}